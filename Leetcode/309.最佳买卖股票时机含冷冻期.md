## 二维区域检索-矩阵不可变
### 题目描述
给定一个整数数组，其中第 *i* 个元素代表了第 *i* 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例**

> 输入:
> A: [1,2,3,0,2]
> 输出: 3
> 解释: 对应状态为[买入，卖出，冷冻期，买入，卖出]。

### 解题思路
#### 思路一
**dp**

某一天必然存在三种状态：

- 手中持有股票：①前一天即持有或 ②前一天不持有且不在冻结期 $dp[i][0] = max(dp[i-1][0],dp[i-1][1]-price[i])$
- 手中不持有股票且不在冻结期：①前一天不持有且不在冻结期 或 ②前一天不持有且在冻结期$dp[i][1] = max(dp[i-1][1],dp[i-1][2])$
- 手中不持有股票且在冻结期：只有可能是前一天有股票，今天卖出, $dp[i-1][2] = dp[i-1][0] + price[i]$

**python实现代码**

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        n = len(prices)
        dp = [[0]*3 for _ in range(n)]
        dp[0][0] = -prices[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
            dp[i][1] = max(dp[i-1][1],dp[i-1][2])
            dp[i][2] = dp[i-1][0] + prices[i]
        return max(dp[-1][1],dp[-1][2])
```



